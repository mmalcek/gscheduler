// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: gs.proto

package _go

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TaskManagerClient is the client API for TaskManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskManagerClient interface {
	AppsList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*List, error)
	TaskCreate(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Status, error)
	TaskUpdate(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Status, error)
	TaskDelete(ctx context.Context, in *TaskUUID, opts ...grpc.CallOption) (*Status, error)
	TaskStop(ctx context.Context, in *TaskUUID, opts ...grpc.CallOption) (*Status, error)
	TaskStart(ctx context.Context, in *TaskUUID, opts ...grpc.CallOption) (*Status, error)
	TaskRun(ctx context.Context, in *TaskUUID, opts ...grpc.CallOption) (*Status, error)
	TasksList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Tasks, error)
	SchedulerStop(ctx context.Context, in *Stop, opts ...grpc.CallOption) (*Status, error)
	SchedulerStart(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	SchedulerWatch(ctx context.Context, in *Empty, opts ...grpc.CallOption) (TaskManager_SchedulerWatchClient, error)
	SchedulerRunningTasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*List, error)
	ExecCmd(ctx context.Context, in *Task, opts ...grpc.CallOption) (*ExecStatus, error)
	LogList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*List, error)
	LogGet(ctx context.Context, in *Request, opts ...grpc.CallOption) (*File, error)
}

type taskManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskManagerClient(cc grpc.ClientConnInterface) TaskManagerClient {
	return &taskManagerClient{cc}
}

func (c *taskManagerClient) AppsList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*List, error) {
	out := new(List)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/AppsList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) TaskCreate(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/TaskCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) TaskUpdate(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/TaskUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) TaskDelete(ctx context.Context, in *TaskUUID, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/TaskDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) TaskStop(ctx context.Context, in *TaskUUID, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/TaskStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) TaskStart(ctx context.Context, in *TaskUUID, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/TaskStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) TaskRun(ctx context.Context, in *TaskUUID, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/TaskRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) TasksList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Tasks, error) {
	out := new(Tasks)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/TasksList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) SchedulerStop(ctx context.Context, in *Stop, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/SchedulerStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) SchedulerStart(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/SchedulerStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) SchedulerWatch(ctx context.Context, in *Empty, opts ...grpc.CallOption) (TaskManager_SchedulerWatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &TaskManager_ServiceDesc.Streams[0], "/gscheduler.TaskManager/SchedulerWatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &taskManagerSchedulerWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TaskManager_SchedulerWatchClient interface {
	Recv() (*TaskLog, error)
	grpc.ClientStream
}

type taskManagerSchedulerWatchClient struct {
	grpc.ClientStream
}

func (x *taskManagerSchedulerWatchClient) Recv() (*TaskLog, error) {
	m := new(TaskLog)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *taskManagerClient) SchedulerRunningTasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*List, error) {
	out := new(List)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/SchedulerRunningTasks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) ExecCmd(ctx context.Context, in *Task, opts ...grpc.CallOption) (*ExecStatus, error) {
	out := new(ExecStatus)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/ExecCmd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) LogList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*List, error) {
	out := new(List)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/LogList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskManagerClient) LogGet(ctx context.Context, in *Request, opts ...grpc.CallOption) (*File, error) {
	out := new(File)
	err := c.cc.Invoke(ctx, "/gscheduler.TaskManager/LogGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskManagerServer is the server API for TaskManager service.
// All implementations must embed UnimplementedTaskManagerServer
// for forward compatibility
type TaskManagerServer interface {
	AppsList(context.Context, *Empty) (*List, error)
	TaskCreate(context.Context, *Task) (*Status, error)
	TaskUpdate(context.Context, *Task) (*Status, error)
	TaskDelete(context.Context, *TaskUUID) (*Status, error)
	TaskStop(context.Context, *TaskUUID) (*Status, error)
	TaskStart(context.Context, *TaskUUID) (*Status, error)
	TaskRun(context.Context, *TaskUUID) (*Status, error)
	TasksList(context.Context, *Empty) (*Tasks, error)
	SchedulerStop(context.Context, *Stop) (*Status, error)
	SchedulerStart(context.Context, *Empty) (*Status, error)
	SchedulerWatch(*Empty, TaskManager_SchedulerWatchServer) error
	SchedulerRunningTasks(context.Context, *Empty) (*List, error)
	ExecCmd(context.Context, *Task) (*ExecStatus, error)
	LogList(context.Context, *Empty) (*List, error)
	LogGet(context.Context, *Request) (*File, error)
	mustEmbedUnimplementedTaskManagerServer()
}

// UnimplementedTaskManagerServer must be embedded to have forward compatible implementations.
type UnimplementedTaskManagerServer struct {
}

func (UnimplementedTaskManagerServer) AppsList(context.Context, *Empty) (*List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppsList not implemented")
}
func (UnimplementedTaskManagerServer) TaskCreate(context.Context, *Task) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskCreate not implemented")
}
func (UnimplementedTaskManagerServer) TaskUpdate(context.Context, *Task) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskUpdate not implemented")
}
func (UnimplementedTaskManagerServer) TaskDelete(context.Context, *TaskUUID) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskDelete not implemented")
}
func (UnimplementedTaskManagerServer) TaskStop(context.Context, *TaskUUID) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskStop not implemented")
}
func (UnimplementedTaskManagerServer) TaskStart(context.Context, *TaskUUID) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskStart not implemented")
}
func (UnimplementedTaskManagerServer) TaskRun(context.Context, *TaskUUID) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskRun not implemented")
}
func (UnimplementedTaskManagerServer) TasksList(context.Context, *Empty) (*Tasks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TasksList not implemented")
}
func (UnimplementedTaskManagerServer) SchedulerStop(context.Context, *Stop) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SchedulerStop not implemented")
}
func (UnimplementedTaskManagerServer) SchedulerStart(context.Context, *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SchedulerStart not implemented")
}
func (UnimplementedTaskManagerServer) SchedulerWatch(*Empty, TaskManager_SchedulerWatchServer) error {
	return status.Errorf(codes.Unimplemented, "method SchedulerWatch not implemented")
}
func (UnimplementedTaskManagerServer) SchedulerRunningTasks(context.Context, *Empty) (*List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SchedulerRunningTasks not implemented")
}
func (UnimplementedTaskManagerServer) ExecCmd(context.Context, *Task) (*ExecStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecCmd not implemented")
}
func (UnimplementedTaskManagerServer) LogList(context.Context, *Empty) (*List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogList not implemented")
}
func (UnimplementedTaskManagerServer) LogGet(context.Context, *Request) (*File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogGet not implemented")
}
func (UnimplementedTaskManagerServer) mustEmbedUnimplementedTaskManagerServer() {}

// UnsafeTaskManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskManagerServer will
// result in compilation errors.
type UnsafeTaskManagerServer interface {
	mustEmbedUnimplementedTaskManagerServer()
}

func RegisterTaskManagerServer(s grpc.ServiceRegistrar, srv TaskManagerServer) {
	s.RegisterService(&TaskManager_ServiceDesc, srv)
}

func _TaskManager_AppsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).AppsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/AppsList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).AppsList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_TaskCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).TaskCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/TaskCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).TaskCreate(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_TaskUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).TaskUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/TaskUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).TaskUpdate(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_TaskDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskUUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).TaskDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/TaskDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).TaskDelete(ctx, req.(*TaskUUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_TaskStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskUUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).TaskStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/TaskStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).TaskStop(ctx, req.(*TaskUUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_TaskStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskUUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).TaskStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/TaskStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).TaskStart(ctx, req.(*TaskUUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_TaskRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskUUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).TaskRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/TaskRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).TaskRun(ctx, req.(*TaskUUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_TasksList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).TasksList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/TasksList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).TasksList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_SchedulerStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Stop)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).SchedulerStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/SchedulerStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).SchedulerStop(ctx, req.(*Stop))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_SchedulerStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).SchedulerStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/SchedulerStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).SchedulerStart(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_SchedulerWatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TaskManagerServer).SchedulerWatch(m, &taskManagerSchedulerWatchServer{stream})
}

type TaskManager_SchedulerWatchServer interface {
	Send(*TaskLog) error
	grpc.ServerStream
}

type taskManagerSchedulerWatchServer struct {
	grpc.ServerStream
}

func (x *taskManagerSchedulerWatchServer) Send(m *TaskLog) error {
	return x.ServerStream.SendMsg(m)
}

func _TaskManager_SchedulerRunningTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).SchedulerRunningTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/SchedulerRunningTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).SchedulerRunningTasks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_ExecCmd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).ExecCmd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/ExecCmd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).ExecCmd(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_LogList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).LogList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/LogList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).LogList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskManager_LogGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskManagerServer).LogGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gscheduler.TaskManager/LogGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskManagerServer).LogGet(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskManager_ServiceDesc is the grpc.ServiceDesc for TaskManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gscheduler.TaskManager",
	HandlerType: (*TaskManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppsList",
			Handler:    _TaskManager_AppsList_Handler,
		},
		{
			MethodName: "TaskCreate",
			Handler:    _TaskManager_TaskCreate_Handler,
		},
		{
			MethodName: "TaskUpdate",
			Handler:    _TaskManager_TaskUpdate_Handler,
		},
		{
			MethodName: "TaskDelete",
			Handler:    _TaskManager_TaskDelete_Handler,
		},
		{
			MethodName: "TaskStop",
			Handler:    _TaskManager_TaskStop_Handler,
		},
		{
			MethodName: "TaskStart",
			Handler:    _TaskManager_TaskStart_Handler,
		},
		{
			MethodName: "TaskRun",
			Handler:    _TaskManager_TaskRun_Handler,
		},
		{
			MethodName: "TasksList",
			Handler:    _TaskManager_TasksList_Handler,
		},
		{
			MethodName: "SchedulerStop",
			Handler:    _TaskManager_SchedulerStop_Handler,
		},
		{
			MethodName: "SchedulerStart",
			Handler:    _TaskManager_SchedulerStart_Handler,
		},
		{
			MethodName: "SchedulerRunningTasks",
			Handler:    _TaskManager_SchedulerRunningTasks_Handler,
		},
		{
			MethodName: "ExecCmd",
			Handler:    _TaskManager_ExecCmd_Handler,
		},
		{
			MethodName: "LogList",
			Handler:    _TaskManager_LogList_Handler,
		},
		{
			MethodName: "LogGet",
			Handler:    _TaskManager_LogGet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SchedulerWatch",
			Handler:       _TaskManager_SchedulerWatch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gs.proto",
}
